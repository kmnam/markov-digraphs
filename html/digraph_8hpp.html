<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MarkovDigraphs: include/digraph.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MarkovDigraphs<span id="projectnumber">&#160;0.9b</span>
   </div>
   <div id="projectbrief">Labeled digraphs &amp; Markov processes for biochemical modeling in the linear framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">digraph.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Main header file for MarkovDigraphs.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;cmath&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;stack&gt;</code><br />
<code>#include &lt;stdexcept&gt;</code><br />
<code>#include &lt;unordered_map&gt;</code><br />
<code>#include &lt;unordered_set&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;Eigen/Dense&gt;</code><br />
<code>#include &lt;Eigen/Sparse&gt;</code><br />
<code>#include &quot;kahan.hpp&quot;</code><br />
<code>#include &quot;KBNSum.hpp&quot;</code><br />
<code>#include &lt;boost/multiprecision/mpfr.hpp&gt;</code><br />
</div>
<p><a href="digraph_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A minimal struct that represents a vertex or node.  <a href="struct_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html">LabeledDigraph&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of a labeled digraph.  <a href="class_labeled_digraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_precise_digraph_3_01_p_01_4.html">PreciseDigraph&lt; P &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of a labeled digraph with boost::multiprecision::number scalar types, for which the template parameter is the number of mantissa digits available to the scalar.  <a href="class_precise_digraph_3_01_p_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5c9c5032dfeec2370815c8f037448006"><td class="memItemLeft" align="right" valign="top"><a id="a5c9c5032dfeec2370815c8f037448006" name="a5c9c5032dfeec2370815c8f037448006"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Edge</b> = std::pair&lt; <a class="el" href="struct_node.html">Node</a> *, <a class="el" href="struct_node.html">Node</a> * &gt;</td></tr>
<tr class="memdesc:a5c9c5032dfeec2370815c8f037448006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edges are simply pairs of <a class="el" href="struct_node.html" title="A minimal struct that represents a vertex or node.">Node</a> pointers. <br /></td></tr>
<tr class="separator:a5c9c5032dfeec2370815c8f037448006"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ad69c7e1a50315928048000e56d50e4e5"><td class="memItemLeft" align="right" valign="top"><a id="ad69c7e1a50315928048000e56d50e4e5" name="ad69c7e1a50315928048000e56d50e4e5"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="digraph_8hpp.html#ad69c7e1a50315928048000e56d50e4e5">SolverMethod</a> { <b>LUDecomposition</b>
, <b>QRDecomposition</b>
 }</td></tr>
<tr class="memdesc:ad69c7e1a50315928048000e56d50e4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">All non-homogeneous linear system solver methods. <br /></td></tr>
<tr class="separator:ad69c7e1a50315928048000e56d50e4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf5fad1560ee564902365e1a668766b"><td class="memItemLeft" align="right" valign="top"><a id="acaf5fad1560ee564902365e1a668766b" name="acaf5fad1560ee564902365e1a668766b"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="digraph_8hpp.html#acaf5fad1560ee564902365e1a668766b">SummationMethod</a> { <b>NaiveSummation</b>
, <b>KahanSummation</b>
, <b>PairwiseSummation</b>
, <b>KBNSummation</b>
 }</td></tr>
<tr class="memdesc:acaf5fad1560ee564902365e1a668766b"><td class="mdescLeft">&#160;</td><td class="mdescRight">All supported summation methods. <br /></td></tr>
<tr class="separator:acaf5fad1560ee564902365e1a668766b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a808bb7b1479e508b4bcac8c2572545f0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a808bb7b1479e508b4bcac8c2572545f0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="digraph_8hpp.html#a808bb7b1479e508b4bcac8c2572545f0">isclose</a> (T a, T b, T tol)</td></tr>
<tr class="memdesc:a808bb7b1479e508b4bcac8c2572545f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if abs(a - b) &lt; tol.  <a href="digraph_8hpp.html#a808bb7b1479e508b4bcac8c2572545f0">More...</a><br /></td></tr>
<tr class="separator:a808bb7b1479e508b4bcac8c2572545f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f91b67dce271751440ad563c496ff6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a74f91b67dce271751440ad563c496ff6"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="digraph_8hpp.html#a74f91b67dce271751440ad563c496ff6">getOneDimNullspaceFromSVD</a> (const Ref&lt; const Matrix&lt; T, Dynamic, Dynamic &gt; &gt; &amp;A)</td></tr>
<tr class="memdesc:a74f91b67dce271751440ad563c496ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nullspace of A by performing a singular value decomposition.  <a href="digraph_8hpp.html#a74f91b67dce271751440ad563c496ff6">More...</a><br /></td></tr>
<tr class="separator:a74f91b67dce271751440ad563c496ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27d8501a9850ab04e97d85c74b37ebd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af27d8501a9850ab04e97d85c74b37ebd"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="digraph_8hpp.html#af27d8501a9850ab04e97d85c74b37ebd">getNullspaceFromSVD</a> (const Ref&lt; const Matrix&lt; T, Dynamic, Dynamic &gt; &gt; &amp;A, const T tol)</td></tr>
<tr class="memdesc:af27d8501a9850ab04e97d85c74b37ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nullspace of A by performing a singular value decomposition.  <a href="digraph_8hpp.html#af27d8501a9850ab04e97d85c74b37ebd">More...</a><br /></td></tr>
<tr class="separator:af27d8501a9850ab04e97d85c74b37ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665f13a351969e1a43e55b3ec52b5d44"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a665f13a351969e1a43e55b3ec52b5d44"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="digraph_8hpp.html#a665f13a351969e1a43e55b3ec52b5d44">solveByLUD</a> (const Ref&lt; const Matrix&lt; T, Dynamic, Dynamic &gt; &gt; &amp;A, const Ref&lt; const Matrix&lt; T, Dynamic, 1 &gt; &gt; &amp;b)</td></tr>
<tr class="memdesc:a665f13a351969e1a43e55b3ec52b5d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the non-homogeneous linear system Ax = b by obtaining an LU decomposition of a matrix A.  <a href="digraph_8hpp.html#a665f13a351969e1a43e55b3ec52b5d44">More...</a><br /></td></tr>
<tr class="separator:a665f13a351969e1a43e55b3ec52b5d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab518b7ef5d025fb7e62d622988742564"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab518b7ef5d025fb7e62d622988742564"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="digraph_8hpp.html#ab518b7ef5d025fb7e62d622988742564">solveByQRD</a> (const Ref&lt; const Matrix&lt; T, Dynamic, Dynamic &gt; &gt; &amp;A, const Ref&lt; const Matrix&lt; T, Dynamic, 1 &gt; &gt; &amp;b)</td></tr>
<tr class="memdesc:ab518b7ef5d025fb7e62d622988742564"><td class="mdescLeft">&#160;</td><td class="mdescRight">NOTE (11/20/2021): The Eigen/SparseLU module offers an implementation of LU decomposition for sparse matrices, but (1) it does not allow for coefficients more precise than double, and (2) it is not designed for row-major matrices.  <a href="digraph_8hpp.html#ab518b7ef5d025fb7e62d622988742564">More...</a><br /></td></tr>
<tr class="separator:ab518b7ef5d025fb7e62d622988742564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd00ab7a48edffee85a11dc94d8903b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aafd00ab7a48edffee85a11dc94d8903b"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="digraph_8hpp.html#aafd00ab7a48edffee85a11dc94d8903b">chebotarevAgaevRecurrence</a> (const Ref&lt; const Matrix&lt; T, Dynamic, Dynamic &gt; &gt; &amp;laplacian, const Ref&lt; const Matrix&lt; T, Dynamic, Dynamic &gt; &gt; &amp;curr, const int k, const <a class="el" href="digraph_8hpp.html#acaf5fad1560ee564902365e1a668766b">SummationMethod</a> method=NaiveSummation)</td></tr>
<tr class="memdesc:aafd00ab7a48edffee85a11dc94d8903b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply one iteration of the recurrence of Chebotarev &amp; Agaev (Lin Alg Appl, 2002, Eqs. 17-18) for the spanning forest matrices of the graph, using a <em>dense</em> Laplacian matrix.  <a href="digraph_8hpp.html#aafd00ab7a48edffee85a11dc94d8903b">More...</a><br /></td></tr>
<tr class="separator:aafd00ab7a48edffee85a11dc94d8903b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e3a17b9398cc09709ce91a137fb4e7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a61e3a17b9398cc09709ce91a137fb4e7"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="digraph_8hpp.html#a61e3a17b9398cc09709ce91a137fb4e7">chebotarevAgaevRecurrence</a> (const SparseMatrix&lt; T, RowMajor &gt; &amp;laplacian, const Ref&lt; const Matrix&lt; T, Dynamic, Dynamic &gt; &gt; &amp;curr, const int k, const <a class="el" href="digraph_8hpp.html#acaf5fad1560ee564902365e1a668766b">SummationMethod</a> method=NaiveSummation)</td></tr>
<tr class="memdesc:a61e3a17b9398cc09709ce91a137fb4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply one iteration of the recurrence of Chebotarev &amp; Agaev (Lin Alg Appl, 2002, Eqs. 17-18) for the spanning forest matrices of the graph, using a <em>compressed sparse row-major</em> Laplacian matrix.  <a href="digraph_8hpp.html#a61e3a17b9398cc09709ce91a137fb4e7">More...</a><br /></td></tr>
<tr class="separator:a61e3a17b9398cc09709ce91a137fb4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Main header file for MarkovDigraphs. </p>
<p >Author: Kee-Myoung Nam, Department of Systems Biology, Harvard Medical School Last updated: 12/1/2021 </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aafd00ab7a48edffee85a11dc94d8903b" name="aafd00ab7a48edffee85a11dc94d8903b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd00ab7a48edffee85a11dc94d8903b">&#9670;&nbsp;</a></span>chebotarevAgaevRecurrence() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt; T, Dynamic, Dynamic &gt; chebotarevAgaevRecurrence </td>
          <td>(</td>
          <td class="paramtype">const Ref&lt; const Matrix&lt; T, Dynamic, Dynamic &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>laplacian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ref&lt; const Matrix&lt; T, Dynamic, Dynamic &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>curr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="digraph_8hpp.html#acaf5fad1560ee564902365e1a668766b">SummationMethod</a>&#160;</td>
          <td class="paramname"><em>method</em> = <code>NaiveSummation</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply one iteration of the recurrence of Chebotarev &amp; Agaev (Lin Alg Appl, 2002, Eqs. 17-18) for the spanning forest matrices of the graph, using a <em>dense</em> Laplacian matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">laplacian</td><td>Input Laplacian matrix. </td></tr>
    <tr><td class="paramname">curr</td><td>k-th spanning forest matrix obtained from previous applications of the Chebotarev-Agaev recurrence. </td></tr>
    <tr><td class="paramname">k</td><td>Index of current iteration. </td></tr>
    <tr><td class="paramname">method</td><td>Summation method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(k+1)-th spanning forest matrix. <br  />
 </dd></dl>

</div>
</div>
<a id="a61e3a17b9398cc09709ce91a137fb4e7" name="a61e3a17b9398cc09709ce91a137fb4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e3a17b9398cc09709ce91a137fb4e7">&#9670;&nbsp;</a></span>chebotarevAgaevRecurrence() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt; T, Dynamic, Dynamic &gt; chebotarevAgaevRecurrence </td>
          <td>(</td>
          <td class="paramtype">const SparseMatrix&lt; T, RowMajor &gt; &amp;&#160;</td>
          <td class="paramname"><em>laplacian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ref&lt; const Matrix&lt; T, Dynamic, Dynamic &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>curr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="digraph_8hpp.html#acaf5fad1560ee564902365e1a668766b">SummationMethod</a>&#160;</td>
          <td class="paramname"><em>method</em> = <code>NaiveSummation</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply one iteration of the recurrence of Chebotarev &amp; Agaev (Lin Alg Appl, 2002, Eqs. 17-18) for the spanning forest matrices of the graph, using a <em>compressed sparse row-major</em> Laplacian matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">laplacian</td><td>Input Laplacian matrix (compressed sparse row-major). </td></tr>
    <tr><td class="paramname">curr</td><td>k-th spanning forest matrix obtained from previous applications of the Chebotarev-Agaev recurrence. </td></tr>
    <tr><td class="paramname">k</td><td>Index of current iteration. </td></tr>
    <tr><td class="paramname">method</td><td>Summation method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(k+1)-th spanning forest matrix. </dd></dl>

</div>
</div>
<a id="af27d8501a9850ab04e97d85c74b37ebd" name="af27d8501a9850ab04e97d85c74b37ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27d8501a9850ab04e97d85c74b37ebd">&#9670;&nbsp;</a></span>getNullspaceFromSVD()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt; T, Dynamic, Dynamic &gt; getNullspaceFromSVD </td>
          <td>(</td>
          <td class="paramtype">const Ref&lt; const Matrix&lt; T, Dynamic, Dynamic &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the nullspace of A by performing a singular value decomposition. </p>
<p >This function returns the column(s) of V in the SVD of A = USV corresponding to singular values with absolute value &lt; tol.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Input matrix to be decomposed. </td></tr>
    <tr><td class="paramname">tol</td><td>Tolerance for singular value to be treated as sufficiently close to zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix of columns in V in the singular value decomposition A = USV corresponding to singular values less than tol. <br  />
 </dd></dl>

</div>
</div>
<a id="a74f91b67dce271751440ad563c496ff6" name="a74f91b67dce271751440ad563c496ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f91b67dce271751440ad563c496ff6">&#9670;&nbsp;</a></span>getOneDimNullspaceFromSVD()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt; T, Dynamic, 1 &gt; getOneDimNullspaceFromSVD </td>
          <td>(</td>
          <td class="paramtype">const Ref&lt; const Matrix&lt; T, Dynamic, Dynamic &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the nullspace of A by performing a singular value decomposition. </p>
<p >This function returns the column of V in the SVD of A = USV corresponding to the least singular value (recall that singular values are always non-negative). It therefore effectively assumes that the A has a nullspace of dimension one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Input matrix to be decomposed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The column of V in the singular value decomposition A = USV corresponding to the least singular value. </dd></dl>

</div>
</div>
<a id="a808bb7b1479e508b4bcac8c2572545f0" name="a808bb7b1479e508b4bcac8c2572545f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808bb7b1479e508b4bcac8c2572545f0">&#9670;&nbsp;</a></span>isclose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool isclose </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if abs(a - b) &lt; tol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first scalar. </td></tr>
    <tr><td class="paramname">b</td><td>second scalar. </td></tr>
    <tr><td class="paramname">tol</td><td>tolerance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if abs(a - b) &lt; tol, false otherwise. <br  />
 </dd></dl>

</div>
</div>
<a id="a665f13a351969e1a43e55b3ec52b5d44" name="a665f13a351969e1a43e55b3ec52b5d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665f13a351969e1a43e55b3ec52b5d44">&#9670;&nbsp;</a></span>solveByLUD()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt; T, Dynamic, 1 &gt; solveByLUD </td>
          <td>(</td>
          <td class="paramtype">const Ref&lt; const Matrix&lt; T, Dynamic, Dynamic &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ref&lt; const Matrix&lt; T, Dynamic, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve the non-homogeneous linear system Ax = b by obtaining an LU decomposition of a matrix A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Input matrix. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Solution vector to Ax = b. <br  />
 </dd></dl>

</div>
</div>
<a id="ab518b7ef5d025fb7e62d622988742564" name="ab518b7ef5d025fb7e62d622988742564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab518b7ef5d025fb7e62d622988742564">&#9670;&nbsp;</a></span>solveByQRD()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt; T, Dynamic, 1 &gt; solveByQRD </td>
          <td>(</td>
          <td class="paramtype">const Ref&lt; const Matrix&lt; T, Dynamic, Dynamic &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ref&lt; const Matrix&lt; T, Dynamic, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NOTE (11/20/2021): The Eigen/SparseLU module offers an implementation of LU decomposition for sparse matrices, but (1) it does not allow for coefficients more precise than double, and (2) it is not designed for row-major matrices. </p>
<p >Solve the non-homogeneous linear system Ax = b by obtaining a QR decomposition of A.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Input matrix. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Solution vector to Ax = b. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
