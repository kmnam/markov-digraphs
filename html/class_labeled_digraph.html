<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MarkovDigraphs: LabeledDigraph&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MarkovDigraphs<span id="projectnumber">&#160;0.9b</span>
   </div>
   <div id="projectbrief">Labeled digraphs &amp; Markov processes for biochemical modeling in the linear framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_labeled_digraph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">LabeledDigraph&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An implementation of a labeled digraph.  
 <a href="class_labeled_digraph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="digraph_8hpp_source.html">digraph.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3757ebf3cde52c325c6d09eba0170284"><td class="memItemLeft" align="right" valign="top"><a id="a3757ebf3cde52c325c6d09eba0170284" name="a3757ebf3cde52c325c6d09eba0170284"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>LabeledDigraph</b> ()</td></tr>
<tr class="memdesc:a3757ebf3cde52c325c6d09eba0170284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor. <br /></td></tr>
<tr class="separator:a3757ebf3cde52c325c6d09eba0170284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cef0ac1b246fc3803f2225d8ce87c31"><td class="memItemLeft" align="right" valign="top"><a id="a3cef0ac1b246fc3803f2225d8ce87c31" name="a3cef0ac1b246fc3803f2225d8ce87c31"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~LabeledDigraph</b> ()</td></tr>
<tr class="memdesc:a3cef0ac1b246fc3803f2225d8ce87c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor; de-allocates each node from heap memory. <br /></td></tr>
<tr class="separator:a3cef0ac1b246fc3803f2225d8ce87c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4136171849fbb84244b2e6dd5aa6ad"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#a7f4136171849fbb84244b2e6dd5aa6ad">getNumNodes</a> () const</td></tr>
<tr class="memdesc:a7f4136171849fbb84244b2e6dd5aa6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of nodes in the graph.  <a href="class_labeled_digraph.html#a7f4136171849fbb84244b2e6dd5aa6ad">More...</a><br /></td></tr>
<tr class="separator:a7f4136171849fbb84244b2e6dd5aa6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa290be731e3afeeeb4bcea558d32877f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#aa290be731e3afeeeb4bcea558d32877f">addNode</a> (std::string id)</td></tr>
<tr class="memdesc:aa290be731e3afeeeb4bcea558d32877f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a node to the graph with the given ID, and return a pointer to the new node.  <a href="class_labeled_digraph.html#aa290be731e3afeeeb4bcea558d32877f">More...</a><br /></td></tr>
<tr class="separator:aa290be731e3afeeeb4bcea558d32877f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b414a8fb180be2b9e0a0389369921f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#a3b414a8fb180be2b9e0a0389369921f7">removeNode</a> (std::string id)</td></tr>
<tr class="memdesc:a3b414a8fb180be2b9e0a0389369921f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a node from the graph with the given ID.  <a href="class_labeled_digraph.html#a3b414a8fb180be2b9e0a0389369921f7">More...</a><br /></td></tr>
<tr class="separator:a3b414a8fb180be2b9e0a0389369921f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b347d2d7698f0f5fcb614d147d31380"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#a9b347d2d7698f0f5fcb614d147d31380">getNode</a> (std::string id) const</td></tr>
<tr class="memdesc:a9b347d2d7698f0f5fcb614d147d31380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the node with the given ID; return <code>nullptr</code> if a node with the given ID does not exist.  <a href="class_labeled_digraph.html#a9b347d2d7698f0f5fcb614d147d31380">More...</a><br /></td></tr>
<tr class="separator:a9b347d2d7698f0f5fcb614d147d31380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84a9451fbacd0549ae9f33600ed41dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#aa84a9451fbacd0549ae9f33600ed41dc">hasNode</a> (std::string id) const</td></tr>
<tr class="memdesc:aa84a9451fbacd0549ae9f33600ed41dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if node with given ID exists in the graph.  <a href="class_labeled_digraph.html#aa84a9451fbacd0549ae9f33600ed41dc">More...</a><br /></td></tr>
<tr class="separator:aa84a9451fbacd0549ae9f33600ed41dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebc4df775ce9a5971c12ea0ee9588cb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#a3ebc4df775ce9a5971c12ea0ee9588cb">getAllNodes</a> () const</td></tr>
<tr class="memdesc:a3ebc4df775ce9a5971c12ea0ee9588cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the canonical ordering of nodes in the graph (<code>this-&gt;order</code>).  <a href="class_labeled_digraph.html#a3ebc4df775ce9a5971c12ea0ee9588cb">More...</a><br /></td></tr>
<tr class="separator:a3ebc4df775ce9a5971c12ea0ee9588cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69dbf82bd1014788a280b1bed724e603"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#a69dbf82bd1014788a280b1bed724e603">addEdge</a> (std::string source_id, std::string target_id, T label=1)</td></tr>
<tr class="memdesc:a69dbf82bd1014788a280b1bed724e603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an edge between two nodes.  <a href="class_labeled_digraph.html#a69dbf82bd1014788a280b1bed724e603">More...</a><br /></td></tr>
<tr class="separator:a69dbf82bd1014788a280b1bed724e603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b80dd31f87e442ec3253fe9b0309d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#ae2b80dd31f87e442ec3253fe9b0309d1">removeEdge</a> (std::string source_id, std::string target_id)</td></tr>
<tr class="memdesc:ae2b80dd31f87e442ec3253fe9b0309d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the edge between the two given nodes.  <a href="class_labeled_digraph.html#ae2b80dd31f87e442ec3253fe9b0309d1">More...</a><br /></td></tr>
<tr class="separator:ae2b80dd31f87e442ec3253fe9b0309d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fa4c6d8c14775486efbcf0708fa4da"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="digraph_8hpp.html#a5c9c5032dfeec2370815c8f037448006">Edge</a>, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#a12fa4c6d8c14775486efbcf0708fa4da">getEdge</a> (std::string source_id, std::string target_id)</td></tr>
<tr class="memdesc:a12fa4c6d8c14775486efbcf0708fa4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the edge between the specified nodes, along with the edge label.  <a href="class_labeled_digraph.html#a12fa4c6d8c14775486efbcf0708fa4da">More...</a><br /></td></tr>
<tr class="separator:a12fa4c6d8c14775486efbcf0708fa4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c031bfbb58f61104d1fb939bfc4e3c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="digraph_8hpp.html#a5c9c5032dfeec2370815c8f037448006">Edge</a>, T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#a45c031bfbb58f61104d1fb939bfc4e3c">getAllEdgesFromNode</a> (std::string source_id)</td></tr>
<tr class="memdesc:a45c031bfbb58f61104d1fb939bfc4e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of outgoing edges from the given source node, given the ID of the source node.  <a href="class_labeled_digraph.html#a45c031bfbb58f61104d1fb939bfc4e3c">More...</a><br /></td></tr>
<tr class="separator:a45c031bfbb58f61104d1fb939bfc4e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71e84854115d45d1431dfea3116c0e9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="digraph_8hpp.html#a5c9c5032dfeec2370815c8f037448006">Edge</a>, T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#ab71e84854115d45d1431dfea3116c0e9">getAllEdgesFromNode</a> (<a class="el" href="struct_node.html">Node</a> *source)</td></tr>
<tr class="memdesc:ab71e84854115d45d1431dfea3116c0e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of outgoing edges from the given source node, given a pointer to the source node.  <a href="class_labeled_digraph.html#ab71e84854115d45d1431dfea3116c0e9">More...</a><br /></td></tr>
<tr class="separator:ab71e84854115d45d1431dfea3116c0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d9b9bb157cc5f3be12c7dfde54f161"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; int, T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#a14d9b9bb157cc5f3be12c7dfde54f161">getAllEdgesFromNode</a> (int source_idx)</td></tr>
<tr class="memdesc:a14d9b9bb157cc5f3be12c7dfde54f161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of outgoing edges from the given source node, given the index of the source node in the canonical ordering (<code>this-&gt;order</code>).  <a href="class_labeled_digraph.html#a14d9b9bb157cc5f3be12c7dfde54f161">More...</a><br /></td></tr>
<tr class="separator:a14d9b9bb157cc5f3be12c7dfde54f161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba7a75963b8d68548a81ff651124706"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#afba7a75963b8d68548a81ff651124706">hasEdge</a> (std::string source_id, std::string target_id) const</td></tr>
<tr class="memdesc:afba7a75963b8d68548a81ff651124706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified edge exists, given the IDs of the two nodes, and false otherwise.  <a href="class_labeled_digraph.html#afba7a75963b8d68548a81ff651124706">More...</a><br /></td></tr>
<tr class="separator:afba7a75963b8d68548a81ff651124706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce9b8c45e73b9b7ffb46f170bbd474b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#a2ce9b8c45e73b9b7ffb46f170bbd474b">hasEdge</a> (<a class="el" href="struct_node.html">Node</a> *source, <a class="el" href="struct_node.html">Node</a> *target) const</td></tr>
<tr class="memdesc:a2ce9b8c45e73b9b7ffb46f170bbd474b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified edge exists, given pointers to the two nodes, and false otherwise.  <a href="class_labeled_digraph.html#a2ce9b8c45e73b9b7ffb46f170bbd474b">More...</a><br /></td></tr>
<tr class="separator:a2ce9b8c45e73b9b7ffb46f170bbd474b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2f9c32a2a017e928fe3c53489c984b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#a9c2f9c32a2a017e928fe3c53489c984b">setEdgeLabel</a> (std::string source_id, std::string target_id, T value)</td></tr>
<tr class="memdesc:a9c2f9c32a2a017e928fe3c53489c984b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the label on the specified edge to the given value.  <a href="class_labeled_digraph.html#a9c2f9c32a2a017e928fe3c53489c984b">More...</a><br /></td></tr>
<tr class="separator:a9c2f9c32a2a017e928fe3c53489c984b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e61b66f48df80f189d7159761ce2d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#a30e61b66f48df80f189d7159761ce2d6">subgraph</a> (std::unordered_set&lt; <a class="el" href="struct_node.html">Node</a> * &gt; <a class="el" href="class_labeled_digraph.html#a92b70ebd09b3e1f7a168c0e2f7a7372f">nodes</a>)</td></tr>
<tr class="memdesc:a30e61b66f48df80f189d7159761ce2d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to a new (dynamically allocated) subgraph induced by the given subset of nodes.  <a href="class_labeled_digraph.html#a30e61b66f48df80f189d7159761ce2d6">More...</a><br /></td></tr>
<tr class="separator:a30e61b66f48df80f189d7159761ce2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db381bb6c8e6f0102a87e501ec781c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#a0db381bb6c8e6f0102a87e501ec781c4">clear</a> ()</td></tr>
<tr class="memdesc:a0db381bb6c8e6f0102a87e501ec781c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the graph's contents.  <a href="class_labeled_digraph.html#a0db381bb6c8e6f0102a87e501ec781c4">More...</a><br /></td></tr>
<tr class="separator:a0db381bb6c8e6f0102a87e501ec781c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9bfd7bc5cd615113f08c2292e3755cd"><td class="memTemplParams" colspan="2">template&lt;typename U  = T&gt; </td></tr>
<tr class="memitem:aa9bfd7bc5cd615113f08c2292e3755cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; U &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#aa9bfd7bc5cd615113f08c2292e3755cd">copy</a> () const</td></tr>
<tr class="memdesc:aa9bfd7bc5cd615113f08c2292e3755cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to a new (dynamically allocated) copy of the graph, possibly with a different scalar type.  <a href="class_labeled_digraph.html#aa9bfd7bc5cd615113f08c2292e3755cd">More...</a><br /></td></tr>
<tr class="separator:aa9bfd7bc5cd615113f08c2292e3755cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ea80f63212f2940bd47107f8205e84"><td class="memTemplParams" colspan="2">template&lt;typename U  = T&gt; </td></tr>
<tr class="memitem:a65ea80f63212f2940bd47107f8205e84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#a65ea80f63212f2940bd47107f8205e84">copy</a> (<a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; U &gt; *graph) const</td></tr>
<tr class="memdesc:a65ea80f63212f2940bd47107f8205e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy over the contents of this graph to another (dynamically allocated) graph, possibly with a different scalar type.  <a href="class_labeled_digraph.html#a65ea80f63212f2940bd47107f8205e84">More...</a><br /></td></tr>
<tr class="separator:a65ea80f63212f2940bd47107f8205e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339bcdb54972142174028c3b9a86f175"><td class="memItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#a339bcdb54972142174028c3b9a86f175">getLaplacian</a> ()</td></tr>
<tr class="memdesc:a339bcdb54972142174028c3b9a86f175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Laplacian matrix with the given scalar type, according to the graph's canonical ordering of nodes.  <a href="class_labeled_digraph.html#a339bcdb54972142174028c3b9a86f175">More...</a><br /></td></tr>
<tr class="separator:a339bcdb54972142174028c3b9a86f175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f677a7bb91321cf116fc915621d8c8e"><td class="memItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#a1f677a7bb91321cf116fc915621d8c8e">getSpanningForestMatrix</a> (const int k, const <a class="el" href="digraph_8hpp.html#acaf5fad1560ee564902365e1a668766b">SummationMethod</a> method=NaiveSummation)</td></tr>
<tr class="memdesc:a1f677a7bb91321cf116fc915621d8c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the k-th spanning forest matrix, using the recurrence of Chebotarev and Agaev (Lin Alg Appl, 2002, Eqs. 17-18), with a <em>dense</em> Laplacian matrix.  <a href="class_labeled_digraph.html#a1f677a7bb91321cf116fc915621d8c8e">More...</a><br /></td></tr>
<tr class="separator:a1f677a7bb91321cf116fc915621d8c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86243cb2ce10c423b090f45c5129b190"><td class="memItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#a86243cb2ce10c423b090f45c5129b190">getSpanningForestMatrixSparse</a> (const int k, const <a class="el" href="digraph_8hpp.html#acaf5fad1560ee564902365e1a668766b">SummationMethod</a> method=NaiveSummation)</td></tr>
<tr class="memdesc:a86243cb2ce10c423b090f45c5129b190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the k-th spanning forest matrix, using the recurrence of Chebotarev and Agaev (Lin Alg Appl, 2002, Eqs. 17-18), with a <em>compressed row-major sparse</em> Laplacian matrix.  <a href="class_labeled_digraph.html#a86243cb2ce10c423b090f45c5129b190">More...</a><br /></td></tr>
<tr class="separator:a86243cb2ce10c423b090f45c5129b190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54adac31234e74e5a528b7d72e44c538"><td class="memItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#a54adac31234e74e5a528b7d72e44c538">getSteadyStateFromSVD</a> ()</td></tr>
<tr class="memdesc:a54adac31234e74e5a528b7d72e44c538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a vector in the kernel of the Laplacian matrix of the graph, normalized by its 1-norm, by singular value decomposition of the Laplacian matrix.  <a href="class_labeled_digraph.html#a54adac31234e74e5a528b7d72e44c538">More...</a><br /></td></tr>
<tr class="separator:a54adac31234e74e5a528b7d72e44c538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a05b81b0a84cb3bf71e7f9a4a7d576d"><td class="memItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#a3a05b81b0a84cb3bf71e7f9a4a7d576d">getSteadyStateFromRecurrence</a> (const bool sparse, const <a class="el" href="digraph_8hpp.html#acaf5fad1560ee564902365e1a668766b">SummationMethod</a> method=NaiveSummation)</td></tr>
<tr class="memdesc:a3a05b81b0a84cb3bf71e7f9a4a7d576d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a vector in the kernel of the Laplacian matrix of the graph, normalized by its 1-norm, by the recurrence of Chebotarev and Agaev (Lin Alg Appl, 2002, Eqs. 17-18).  <a href="class_labeled_digraph.html#a3a05b81b0a84cb3bf71e7f9a4a7d576d">More...</a><br /></td></tr>
<tr class="separator:a3a05b81b0a84cb3bf71e7f9a4a7d576d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8c4ab453fd42bf467547ee7df99ec7"><td class="memItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#adf8c4ab453fd42bf467547ee7df99ec7">getMeanFirstPassageTimesFromSolver</a> (<a class="el" href="struct_node.html">Node</a> *target, const <a class="el" href="digraph_8hpp.html#ad69c7e1a50315928048000e56d50e4e5">SolverMethod</a> method=QRDecomposition)</td></tr>
<tr class="memdesc:adf8c4ab453fd42bf467547ee7df99ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the vector of <em>unconditional</em> mean first-passage times in the Markov process associated with the graph from each node to the target node, using the given linear solver method.  <a href="class_labeled_digraph.html#adf8c4ab453fd42bf467547ee7df99ec7">More...</a><br /></td></tr>
<tr class="separator:adf8c4ab453fd42bf467547ee7df99ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8d942ffd956b49677d7a3b9d4fcf83"><td class="memItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#acd8d942ffd956b49677d7a3b9d4fcf83">getMeanFirstPassageTimesFromRecurrence</a> (<a class="el" href="struct_node.html">Node</a> *target, const bool sparse, const <a class="el" href="digraph_8hpp.html#acaf5fad1560ee564902365e1a668766b">SummationMethod</a> method=NaiveSummation)</td></tr>
<tr class="memdesc:acd8d942ffd956b49677d7a3b9d4fcf83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the vector of <em>unconditional</em> mean first-passage times in the Markov process associated with the graph from each node to the target node, using the recurrence of Chebotarev and Agaev (Lin Alg Appl, 2002, Eqs. 17-18).  <a href="class_labeled_digraph.html#acd8d942ffd956b49677d7a3b9d4fcf83">More...</a><br /></td></tr>
<tr class="separator:acd8d942ffd956b49677d7a3b9d4fcf83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9dee336b8316d3964d8816974fc8716"><td class="memItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#ad9dee336b8316d3964d8816974fc8716">getSecondMomentsOfFirstPassageTimesFromSolver</a> (<a class="el" href="struct_node.html">Node</a> *target, const <a class="el" href="digraph_8hpp.html#ad69c7e1a50315928048000e56d50e4e5">SolverMethod</a> method=QRDecomposition)</td></tr>
<tr class="memdesc:ad9dee336b8316d3964d8816974fc8716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the vector of second moments of the <em>unconditional</em> first-passage times in the Markov process associated with the graph from each node to the target node, using the given linear solver method.  <a href="class_labeled_digraph.html#ad9dee336b8316d3964d8816974fc8716">More...</a><br /></td></tr>
<tr class="separator:ad9dee336b8316d3964d8816974fc8716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f10917f387f92f9aac525b53e76e0c"><td class="memItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#aa7f10917f387f92f9aac525b53e76e0c">getSecondMomentsOfFirstPassageTimesFromRecurrence</a> (<a class="el" href="struct_node.html">Node</a> *target, const bool sparse, const <a class="el" href="digraph_8hpp.html#acaf5fad1560ee564902365e1a668766b">SummationMethod</a> method=NaiveSummation)</td></tr>
<tr class="memdesc:aa7f10917f387f92f9aac525b53e76e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the vector of second moments of the <em>unconditional</em> first-passage times in the Markov process associated with the graph from each node to the target node, using the recurrence of Chebotarev and Agaev (Lin Alg Appl, 2002, Eqs. 17-18).  <a href="class_labeled_digraph.html#aa7f10917f387f92f9aac525b53e76e0c">More...</a><br /></td></tr>
<tr class="separator:aa7f10917f387f92f9aac525b53e76e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5e368d37e363f4b78ebabdfbc8338a9b"><td class="memItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#a5e368d37e363f4b78ebabdfbc8338a9b">getSpanningForestMatrix</a> (int k, const Ref&lt; const Matrix&lt; T, Dynamic, Dynamic &gt; &gt; &amp;laplacian, const <a class="el" href="digraph_8hpp.html#acaf5fad1560ee564902365e1a668766b">SummationMethod</a> method=NaiveSummation)</td></tr>
<tr class="memdesc:a5e368d37e363f4b78ebabdfbc8338a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the k-th spanning forest matrix, using the recurrence of Chebotarev and Agaev (Lin Alg Appl, 2002, Eqs. 17-18), with a <em>dense</em> Laplacian matrix.  <a href="class_labeled_digraph.html#a5e368d37e363f4b78ebabdfbc8338a9b">More...</a><br /></td></tr>
<tr class="separator:a5e368d37e363f4b78ebabdfbc8338a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14955e6053a808f22625e06546545c19"><td class="memItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_labeled_digraph.html#a14955e6053a808f22625e06546545c19">getSpanningForestMatrixSparse</a> (int k, const SparseMatrix&lt; T, RowMajor &gt; &amp;laplacian, const <a class="el" href="digraph_8hpp.html#acaf5fad1560ee564902365e1a668766b">SummationMethod</a> method=NaiveSummation)</td></tr>
<tr class="memdesc:a14955e6053a808f22625e06546545c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the k-th spanning forest matrix, using the recurrence of Chebotarev and Agaev (Lin Alg Appl, 2002, Eqs. 17-18), with a <em>compressed sparse row-major</em> Laplacian matrix.  <a href="class_labeled_digraph.html#a14955e6053a808f22625e06546545c19">More...</a><br /></td></tr>
<tr class="separator:a14955e6053a808f22625e06546545c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a43697ff05198d45ab2d5dbde0ef785d0"><td class="memItemLeft" align="right" valign="top"><a id="a43697ff05198d45ab2d5dbde0ef785d0" name="a43697ff05198d45ab2d5dbde0ef785d0"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>numnodes</b> = 0</td></tr>
<tr class="memdesc:a43697ff05198d45ab2d5dbde0ef785d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes in the graph. <br /></td></tr>
<tr class="separator:a43697ff05198d45ab2d5dbde0ef785d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5500b79e7c778fe4f027f93efd52a5"><td class="memItemLeft" align="right" valign="top"><a id="a5a5500b79e7c778fe4f027f93efd52a5" name="a5a5500b79e7c778fe4f027f93efd52a5"></a>
std::vector&lt; <a class="el" href="struct_node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>order</b></td></tr>
<tr class="memdesc:a5a5500b79e7c778fe4f027f93efd52a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonical ordering of nodes. <br /></td></tr>
<tr class="separator:a5a5500b79e7c778fe4f027f93efd52a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b70ebd09b3e1f7a168c0e2f7a7372f"><td class="memItemLeft" align="right" valign="top"><a id="a92b70ebd09b3e1f7a168c0e2f7a7372f" name="a92b70ebd09b3e1f7a168c0e2f7a7372f"></a>
std::unordered_map&lt; std::string, <a class="el" href="struct_node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>nodes</b></td></tr>
<tr class="memdesc:a92b70ebd09b3e1f7a168c0e2f7a7372f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dictionary that maps <code><a class="el" href="struct_node.html" title="A minimal struct that represents a vertex or node.">Node</a></code> IDs to <code><a class="el" href="struct_node.html" title="A minimal struct that represents a vertex or node.">Node</a></code> pointers. <br /></td></tr>
<tr class="separator:a92b70ebd09b3e1f7a168c0e2f7a7372f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94349d9c41299782fb9a6aa89502ccdc"><td class="memItemLeft" align="right" valign="top"><a id="a94349d9c41299782fb9a6aa89502ccdc" name="a94349d9c41299782fb9a6aa89502ccdc"></a>
std::unordered_map&lt; <a class="el" href="struct_node.html">Node</a> *, std::unordered_map&lt; <a class="el" href="struct_node.html">Node</a> *, T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>edges</b></td></tr>
<tr class="memdesc:a94349d9c41299782fb9a6aa89502ccdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dictionary that maps outgoing edges from each <code><a class="el" href="struct_node.html" title="A minimal struct that represents a vertex or node.">Node</a></code>, along with edge labels. <br /></td></tr>
<tr class="separator:a94349d9c41299782fb9a6aa89502ccdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class LabeledDigraph&lt; T &gt;</div><p >An implementation of a labeled digraph. </p>
<p ><br  />
 </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a69dbf82bd1014788a280b1bed724e603" name="a69dbf82bd1014788a280b1bed724e603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69dbf82bd1014788a280b1bed724e603">&#9670;&nbsp;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::addEdge </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>source_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>target_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>label</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an edge between two nodes. </p>
<p >If either ID does not correspond to a node in the graph, this function instantiates these nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_id</td><td>ID of source node of new edge. </td></tr>
    <tr><td class="paramname">target_id</td><td>ID of target node of new edge. </td></tr>
    <tr><td class="paramname">label</td><td>Label on new edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the edge already exists. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa290be731e3afeeeb4bcea558d32877f" name="aa290be731e3afeeeb4bcea558d32877f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa290be731e3afeeeb4bcea558d32877f">&#9670;&nbsp;</a></span>addNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_node.html">Node</a> * <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::addNode </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a node to the graph with the given ID, and return a pointer to the new node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID for new node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to new node. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if node already exists with the given ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0db381bb6c8e6f0102a87e501ec781c4" name="a0db381bb6c8e6f0102a87e501ec781c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db381bb6c8e6f0102a87e501ec781c4">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the graph's contents. </p>
<p ><br  />
 </p>

</div>
</div>
<a id="aa9bfd7bc5cd615113f08c2292e3755cd" name="aa9bfd7bc5cd615113f08c2292e3755cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9bfd7bc5cd615113f08c2292e3755cd">&#9670;&nbsp;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; U &gt; * <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to a new (dynamically allocated) copy of the graph, possibly with a different scalar type. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new copy of the graph. </dd></dl>

</div>
</div>
<a id="a65ea80f63212f2940bd47107f8205e84" name="a65ea80f63212f2940bd47107f8205e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ea80f63212f2940bd47107f8205e84">&#9670;&nbsp;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; U &gt; *&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy over the contents of this graph to another (dynamically allocated) graph, possibly with a different scalar type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>A pointer to another graph instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14d9b9bb157cc5f3be12c7dfde54f161" name="a14d9b9bb157cc5f3be12c7dfde54f161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d9b9bb157cc5f3be12c7dfde54f161">&#9670;&nbsp;</a></span>getAllEdgesFromNode() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; int, T &gt; &gt; <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::getAllEdgesFromNode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source_idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a vector of outgoing edges from the given source node, given the index of the source node in the canonical ordering (<code>this-&gt;order</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_idx</td><td>Index of source node in the canonical ordering. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std::vector</code> of pairs containing the target node index and label of each edge </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the given node does not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab71e84854115d45d1431dfea3116c0e9" name="ab71e84854115d45d1431dfea3116c0e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71e84854115d45d1431dfea3116c0e9">&#9670;&nbsp;</a></span>getAllEdgesFromNode() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; <a class="el" href="digraph_8hpp.html#a5c9c5032dfeec2370815c8f037448006">Edge</a>, T &gt; &gt; <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::getAllEdgesFromNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a vector of outgoing edges from the given source node, given a pointer to the source node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Pointer to source node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std::vector</code> of pairs containing each edge (as a <code>&lt;Node*, Node*&gt;</code> pair) and edge label </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the given node does not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45c031bfbb58f61104d1fb939bfc4e3c" name="a45c031bfbb58f61104d1fb939bfc4e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c031bfbb58f61104d1fb939bfc4e3c">&#9670;&nbsp;</a></span>getAllEdgesFromNode() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; <a class="el" href="digraph_8hpp.html#a5c9c5032dfeec2370815c8f037448006">Edge</a>, T &gt; &gt; <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::getAllEdgesFromNode </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>source_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a vector of outgoing edges from the given source node, given the ID of the source node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_id</td><td>ID of source node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std::vector</code> of pairs containing each edge (as a <code>&lt;Node*, Node*&gt;</code> pair) and edge label </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if a node with the given ID does not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ebc4df775ce9a5971c12ea0ee9588cb" name="a3ebc4df775ce9a5971c12ea0ee9588cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ebc4df775ce9a5971c12ea0ee9588cb">&#9670;&nbsp;</a></span>getAllNodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_node.html">Node</a> * &gt; <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::getAllNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the canonical ordering of nodes in the graph (<code>this-&gt;order</code>). </p>
<dl class="section return"><dt>Returns</dt><dd>A copy of <code>this-&gt;order</code>. </dd></dl>

</div>
</div>
<a id="a12fa4c6d8c14775486efbcf0708fa4da" name="a12fa4c6d8c14775486efbcf0708fa4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12fa4c6d8c14775486efbcf0708fa4da">&#9670;&nbsp;</a></span>getEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="digraph_8hpp.html#a5c9c5032dfeec2370815c8f037448006">Edge</a>, T &gt; <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::getEdge </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>source_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>target_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the edge between the specified nodes, along with the edge label. </p>
<p >This method returns a <code>nullptr</code> pair and zero for the edge label if the edge does not exist but the nodes do, but throws an exception if either node does not exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_id</td><td>ID of source node. </td></tr>
    <tr><td class="paramname">target_id</td><td>ID of target node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair containing the edge (as a <code>&lt;Node*, Node*&gt;</code> pair) and the edge label. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if either node does not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a339bcdb54972142174028c3b9a86f175" name="a339bcdb54972142174028c3b9a86f175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a339bcdb54972142174028c3b9a86f175">&#9670;&nbsp;</a></span>getLaplacian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt; T, Dynamic, Dynamic &gt; <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::getLaplacian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the Laplacian matrix with the given scalar type, according to the graph's canonical ordering of nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>Laplacian matrix of the graph (as a dense matrix). </dd></dl>

</div>
</div>
<a id="acd8d942ffd956b49677d7a3b9d4fcf83" name="acd8d942ffd956b49677d7a3b9d4fcf83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8d942ffd956b49677d7a3b9d4fcf83">&#9670;&nbsp;</a></span>getMeanFirstPassageTimesFromRecurrence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt; T, Dynamic, 1 &gt; <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::getMeanFirstPassageTimesFromRecurrence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>sparse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="digraph_8hpp.html#acaf5fad1560ee564902365e1a668766b">SummationMethod</a>&#160;</td>
          <td class="paramname"><em>method</em> = <code>NaiveSummation</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the vector of <em>unconditional</em> mean first-passage times in the Markov process associated with the graph from each node to the target node, using the recurrence of Chebotarev and Agaev (Lin Alg Appl, 2002, Eqs. 17-18). </p>
<p >This method assumes that the associated Markov process certainly eventually reaches the target node from each node in the graph, meaning that there are no alternative terminal nodes (or rather SCCs) to which the process can travel and get "stuck". <br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Pointer to target node. </td></tr>
    <tr><td class="paramname">sparse</td><td>If true, use a sparse Laplacian matrix in the calculations. </td></tr>
    <tr><td class="paramname">method</td><td>Summation method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of mean first-passage times to the target node from every node in the graph. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if summation method is not recognized. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf8c4ab453fd42bf467547ee7df99ec7" name="adf8c4ab453fd42bf467547ee7df99ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf8c4ab453fd42bf467547ee7df99ec7">&#9670;&nbsp;</a></span>getMeanFirstPassageTimesFromSolver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt; T, Dynamic, 1 &gt; <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::getMeanFirstPassageTimesFromSolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="digraph_8hpp.html#ad69c7e1a50315928048000e56d50e4e5">SolverMethod</a>&#160;</td>
          <td class="paramname"><em>method</em> = <code>QRDecomposition</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the vector of <em>unconditional</em> mean first-passage times in the Markov process associated with the graph from each node to the target node, using the given linear solver method. </p>
<p >This method assumes that the associated Markov process certainly eventually reaches the target node from each node in the graph, meaning that there are no alternative terminal nodes (or rather SCCs) to which the process can travel and get "stuck". <br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Pointer to target node. </td></tr>
    <tr><td class="paramname">method</td><td>Linear solver method for computing the mean first-passage time vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of mean first-passage times to the target node from every node in the graph. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if solver method is not recognized. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b347d2d7698f0f5fcb614d147d31380" name="a9b347d2d7698f0f5fcb614d147d31380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b347d2d7698f0f5fcb614d147d31380">&#9670;&nbsp;</a></span>getNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_node.html">Node</a> * <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::getNode </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the node with the given ID; return <code>nullptr</code> if a node with the given ID does not exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of desired node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to node with the given ID (<code>nullptr</code> if such a node does not exist). </dd></dl>

</div>
</div>
<a id="a7f4136171849fbb84244b2e6dd5aa6ad" name="a7f4136171849fbb84244b2e6dd5aa6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4136171849fbb84244b2e6dd5aa6ad">&#9670;&nbsp;</a></span>getNumNodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::getNumNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of nodes in the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of nodes in the graph. <br  />
 </dd></dl>

</div>
</div>
<a id="aa7f10917f387f92f9aac525b53e76e0c" name="aa7f10917f387f92f9aac525b53e76e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f10917f387f92f9aac525b53e76e0c">&#9670;&nbsp;</a></span>getSecondMomentsOfFirstPassageTimesFromRecurrence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt; T, Dynamic, 1 &gt; <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::getSecondMomentsOfFirstPassageTimesFromRecurrence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>sparse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="digraph_8hpp.html#acaf5fad1560ee564902365e1a668766b">SummationMethod</a>&#160;</td>
          <td class="paramname"><em>method</em> = <code>NaiveSummation</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the vector of second moments of the <em>unconditional</em> first-passage times in the Markov process associated with the graph from each node to the target node, using the recurrence of Chebotarev and Agaev (Lin Alg Appl, 2002, Eqs. 17-18). </p>
<p >This method assumes that the associated Markov process certainly eventually reaches the target node from each node in the graph, meaning that there are no alternative terminal nodes (or rather SCCs) to which the process can travel and get "stuck".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Pointer to target node. </td></tr>
    <tr><td class="paramname">sparse</td><td>If true, use a sparse Laplacian matrix in the calculations. </td></tr>
    <tr><td class="paramname">method</td><td>Summation method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of first-passage time second moments to the target node from every node in the graph. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if summation method is not recognized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9dee336b8316d3964d8816974fc8716" name="ad9dee336b8316d3964d8816974fc8716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9dee336b8316d3964d8816974fc8716">&#9670;&nbsp;</a></span>getSecondMomentsOfFirstPassageTimesFromSolver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt; T, Dynamic, 1 &gt; <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::getSecondMomentsOfFirstPassageTimesFromSolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="digraph_8hpp.html#ad69c7e1a50315928048000e56d50e4e5">SolverMethod</a>&#160;</td>
          <td class="paramname"><em>method</em> = <code>QRDecomposition</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the vector of second moments of the <em>unconditional</em> first-passage times in the Markov process associated with the graph from each node to the target node, using the given linear solver method. </p>
<p >This method assumes that the associated Markov process certainly eventually reaches the target node from each node in the graph, meaning that there are no alternative terminal nodes (or rather SCCs) to which the process can travel and get "stuck". <br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Pointer to target node. </td></tr>
    <tr><td class="paramname">method</td><td>Linear solver method for computing the second-moment time vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of first-passage time second moments to the target node from every node in the graph. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if solver method is not recognized. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f677a7bb91321cf116fc915621d8c8e" name="a1f677a7bb91321cf116fc915621d8c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f677a7bb91321cf116fc915621d8c8e">&#9670;&nbsp;</a></span>getSpanningForestMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt; T, Dynamic, Dynamic &gt; <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::getSpanningForestMatrix </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="digraph_8hpp.html#acaf5fad1560ee564902365e1a668766b">SummationMethod</a>&#160;</td>
          <td class="paramname"><em>method</em> = <code>NaiveSummation</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the k-th spanning forest matrix, using the recurrence of Chebotarev and Agaev (Lin Alg Appl, 2002, Eqs. 17-18), with a <em>dense</em> Laplacian matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Index of the desired spanning forest matrix. </td></tr>
    <tr><td class="paramname">method</td><td>Summation method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>k-th spanning forest matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if summation method is not recognized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e368d37e363f4b78ebabdfbc8338a9b" name="a5e368d37e363f4b78ebabdfbc8338a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e368d37e363f4b78ebabdfbc8338a9b">&#9670;&nbsp;</a></span>getSpanningForestMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt; T, Dynamic, Dynamic &gt; <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::getSpanningForestMatrix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ref&lt; const Matrix&lt; T, Dynamic, Dynamic &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>laplacian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="digraph_8hpp.html#acaf5fad1560ee564902365e1a668766b">SummationMethod</a>&#160;</td>
          <td class="paramname"><em>method</em> = <code>NaiveSummation</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the k-th spanning forest matrix, using the recurrence of Chebotarev and Agaev (Lin Alg Appl, 2002, Eqs. 17-18), with a <em>dense</em> Laplacian matrix. </p>
<p >A private version of the corresponding public method, in which a pre-computed Laplacian matrix is provided as an argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Index of desired spanning forest matrix. <br  />
 </td></tr>
    <tr><td class="paramname">laplacian</td><td>Input Laplacian matrix. </td></tr>
    <tr><td class="paramname">method</td><td>Summation method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>k-th spanning forest matrix. </dd></dl>

</div>
</div>
<a id="a86243cb2ce10c423b090f45c5129b190" name="a86243cb2ce10c423b090f45c5129b190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86243cb2ce10c423b090f45c5129b190">&#9670;&nbsp;</a></span>getSpanningForestMatrixSparse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt; T, Dynamic, Dynamic &gt; <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::getSpanningForestMatrixSparse </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="digraph_8hpp.html#acaf5fad1560ee564902365e1a668766b">SummationMethod</a>&#160;</td>
          <td class="paramname"><em>method</em> = <code>NaiveSummation</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the k-th spanning forest matrix, using the recurrence of Chebotarev and Agaev (Lin Alg Appl, 2002, Eqs. 17-18), with a <em>compressed row-major sparse</em> Laplacian matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Index of the desired spanning forest matrix. </td></tr>
    <tr><td class="paramname">method</td><td>Summation method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>k-th spanning forest matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if summation method is not recognized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14955e6053a808f22625e06546545c19" name="a14955e6053a808f22625e06546545c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14955e6053a808f22625e06546545c19">&#9670;&nbsp;</a></span>getSpanningForestMatrixSparse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt; T, Dynamic, Dynamic &gt; <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::getSpanningForestMatrixSparse </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparseMatrix&lt; T, RowMajor &gt; &amp;&#160;</td>
          <td class="paramname"><em>laplacian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="digraph_8hpp.html#acaf5fad1560ee564902365e1a668766b">SummationMethod</a>&#160;</td>
          <td class="paramname"><em>method</em> = <code>NaiveSummation</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the k-th spanning forest matrix, using the recurrence of Chebotarev and Agaev (Lin Alg Appl, 2002, Eqs. 17-18), with a <em>compressed sparse row-major</em> Laplacian matrix. </p>
<p >A private version of the corresponding public method, in which a pre-computed Laplacian matrix is provided as an argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Index of desired spanning forest matrix. <br  />
 </td></tr>
    <tr><td class="paramname">laplacian</td><td>Input Laplacian matrix (compressed sparse row-major). </td></tr>
    <tr><td class="paramname">method</td><td>Summation method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>k-th spanning forest matrix. </dd></dl>

</div>
</div>
<a id="a3a05b81b0a84cb3bf71e7f9a4a7d576d" name="a3a05b81b0a84cb3bf71e7f9a4a7d576d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a05b81b0a84cb3bf71e7f9a4a7d576d">&#9670;&nbsp;</a></span>getSteadyStateFromRecurrence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt; T, Dynamic, 1 &gt; <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::getSteadyStateFromRecurrence </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>sparse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="digraph_8hpp.html#acaf5fad1560ee564902365e1a668766b">SummationMethod</a>&#160;</td>
          <td class="paramname"><em>method</em> = <code>NaiveSummation</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a vector in the kernel of the Laplacian matrix of the graph, normalized by its 1-norm, by the recurrence of Chebotarev and Agaev (Lin Alg Appl, 2002, Eqs. 17-18). </p>
<p >This vector coincides with the vector of steady-state probabilities of the nodes in the Markov process associated with the graph.</p>
<p >This method <em>assumes</em> that this graph is strongly connected, in which case the Laplacian matrix has a one-dimensional kernel and so the returned vector serves as a basis for this kernel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sparse</td><td>If true, use a sparse Laplacian matrix in the calculations. </td></tr>
    <tr><td class="paramname">method</td><td>Summation method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector in the kernel of the graph's Laplacian matrix, normalized by its 1-norm. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if summation method is not recognized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54adac31234e74e5a528b7d72e44c538" name="a54adac31234e74e5a528b7d72e44c538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54adac31234e74e5a528b7d72e44c538">&#9670;&nbsp;</a></span>getSteadyStateFromSVD()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt; T, Dynamic, 1 &gt; <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::getSteadyStateFromSVD </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a vector in the kernel of the Laplacian matrix of the graph, normalized by its 1-norm, by singular value decomposition of the Laplacian matrix. </p>
<p >This vector coincides with the vector of steady-state probabilities of the nodes in the Markov process associated with the graph.</p>
<p >This method <em>assumes</em> that this graph is strongly connected, in which case the Laplacian matrix has a one-dimensional kernel and so the returned vector serves as a basis for this kernel.</p>
<dl class="section return"><dt>Returns</dt><dd>Vector in the kernel of the graph's Laplacian matrix, normalized by its 1-norm. </dd></dl>

</div>
</div>
<a id="a2ce9b8c45e73b9b7ffb46f170bbd474b" name="a2ce9b8c45e73b9b7ffb46f170bbd474b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce9b8c45e73b9b7ffb46f170bbd474b">&#9670;&nbsp;</a></span>hasEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::hasEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the specified edge exists, given pointers to the two nodes, and false otherwise. </p>
<p >This method also returns false if either node does not exist. <br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Pointer to source node. </td></tr>
    <tr><td class="paramname">target</td><td>Pointer to target node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the edge exists, false otherwise. <br  />
 </dd></dl>

</div>
</div>
<a id="afba7a75963b8d68548a81ff651124706" name="afba7a75963b8d68548a81ff651124706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba7a75963b8d68548a81ff651124706">&#9670;&nbsp;</a></span>hasEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::hasEdge </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>source_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>target_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the specified edge exists, given the IDs of the two nodes, and false otherwise. </p>
<p >This method also returns false if either node does not exist. <br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_id</td><td>ID of source node. </td></tr>
    <tr><td class="paramname">target_id</td><td>ID of target node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the edge exists, false otherwise. <br  />
 </dd></dl>

</div>
</div>
<a id="aa84a9451fbacd0549ae9f33600ed41dc" name="aa84a9451fbacd0549ae9f33600ed41dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84a9451fbacd0549ae9f33600ed41dc">&#9670;&nbsp;</a></span>hasNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::hasNode </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if node with given ID exists in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of desired node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if node exists with the given ID, false otherwise. <br  />
 </dd></dl>

</div>
</div>
<a id="ae2b80dd31f87e442ec3253fe9b0309d1" name="ae2b80dd31f87e442ec3253fe9b0309d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b80dd31f87e442ec3253fe9b0309d1">&#9670;&nbsp;</a></span>removeEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::removeEdge </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>source_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>target_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the edge between the two given nodes. </p>
<p >This method does nothing if the edge does not exist but the nodes do, but throws an exception if either node does not exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_id</td><td>ID of source node of edge to be removed. </td></tr>
    <tr><td class="paramname">target_id</td><td>ID of target node of edge to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if either node does not exist. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b414a8fb180be2b9e0a0389369921f7" name="a3b414a8fb180be2b9e0a0389369921f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b414a8fb180be2b9e0a0389369921f7">&#9670;&nbsp;</a></span>removeNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::removeNode </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a node from the graph with the given ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of node to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if node with given ID does not exist. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c2f9c32a2a017e928fe3c53489c984b" name="a9c2f9c32a2a017e928fe3c53489c984b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c2f9c32a2a017e928fe3c53489c984b">&#9670;&nbsp;</a></span>setEdgeLabel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::setEdgeLabel </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>source_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>target_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the label on the specified edge to the given value. </p>
<p >This method throws an exception if either node does not exist, and also if the specified edge does not exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_id</td><td>ID of source node. </td></tr>
    <tr><td class="paramname">target_id</td><td>ID of target node. </td></tr>
    <tr><td class="paramname">value</td><td>New edge label. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if either node or the edge does not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30e61b66f48df80f189d7159761ce2d6" name="a30e61b66f48df80f189d7159761ce2d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e61b66f48df80f189d7159761ce2d6">&#9670;&nbsp;</a></span>subgraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt; * <a class="el" href="class_labeled_digraph.html">LabeledDigraph</a>&lt; T &gt;::subgraph </td>
          <td>(</td>
          <td class="paramtype">std::unordered_set&lt; <a class="el" href="struct_node.html">Node</a> * &gt;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to a new (dynamically allocated) subgraph induced by the given subset of nodes. </p>
<p >An exception is thrown if a node in the given subset does not exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodes</td><td>An unordered set of pointers to nodes in the graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the induced subgraph (instantiated as a new <code><a class="el" href="class_labeled_digraph.html" title="An implementation of a labeled digraph.">LabeledDigraph</a></code> object). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the given subset contains a node that does not exist in the graph. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="digraph_8hpp_source.html">digraph.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
